<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Callback Hell</title>

    <link rel="stylesheet" href="stylesheets/style.css">
    <link rel="stylesheet" href="stylesheets/rainbow.github.css">

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div id="container">
      <div id="main">
        <div id="post" class="sticky-menu">
          <div class="inner clearfix">
            <div class="document prose">
              <div class="surface preview">
                <div class="content-preview-wrapper">
                  <div class="content-preview">
                    <div class="post-content">
                      # Ад&nbsp;обратных вызовов

                      *Руководство по созданию асинхронных программ на&nbsp;JavaScript.*

                      ### Что такое&nbsp;«ад обратных вызовов»?

                      Асинхронный JavaScript или JavaScript, в котором используются обратные вызовы&nbsp;&mdash; это&nbsp;то, в&nbsp;чём трудно интуитивно разобраться. В основном код заканчивается вот так:

                          fs.readdir(source, function (err, files) {
                            if (err) {
                              console.log('Error finding files: ' + err)
                            } else {
                              files.forEach(function (filename, fileIndex) {
                                console.log(filename)
                                gm(source + filename).size(function (err, values) {
                                  if (err) {
                                    console.log('Error identifying file size: ' + err)
                                  } else {
                                    console.log(filename + ' : ' + values)
                                    aspect = (values.width / values.height)
                                    widths.forEach(function (width, widthIndex) {
                                      height = Math.round(width / aspect)
                                      console.log('resizing ' + filename + 'to ' + height + 'x' + height)
                                      this.resize(width, height).write(dest + 'w' + width + '_' + filename, function(err) {
                                        if (err) console.log('Error writing file: ' + err)
                                      })
                                    }.bind(this))
                                  }
                                })
                              })
                            }
                          })

                      Видите форму пирамиды и&nbsp;все эти `})` в&nbsp;конце? Иу! Это ласково называют **адом обратных вызовов** (callback hell).

                      Причина ада кроется в&nbsp;том, что люди пытаются писать JavaScript так, будто его выполнение происходит последовательно сверху вниз. Многие разработчики делают эту ошибку. В&nbsp;других языках, таких как C, Ruby или Python многие ожидают, что происходящее на&nbsp;строке 1&nbsp;завершится перед тем, как выполнение перейдёт на&nbsp;строку 2&nbsp;и&nbsp;так далее вниз до&nbsp;конца файла. Как вы&nbsp;дальше узнаете, JavaScript работает иначе.

                      ## Что такое обратные вызовы?

                      Обратные вызовы&nbsp;&mdash; общепринятое название для функций в&nbsp;JavaScript. Это не&nbsp;особая функция, которая называется &laquo;обратный вызов&raquo;, а&nbsp;соглашение. Вместо того, чтобы сразу&nbsp;же вернуть какой-то результат, как делает большинство функций, функции, использующие обратные вызовы требуют время для получения результата. Слово &laquo;асинхронный&raquo; или &laquo;async&raquo; значит, что оно &laquo;занимает какое-то время&raquo; или &laquo;случится в&nbsp;будущем, не&nbsp;сейчас&raquo;. Обычно обратные вызовы используются только при выполнении ввода-вывода (I/O&nbsp;&mdash; input-output), например, при загрузке, чтении файлов, обмене информации с&nbsp;базами данных и&nbsp;так далее.

                      Когда вы&nbsp;вызываете обычную функцию, вы&nbsp;можете использовать её&nbsp;возвращаемое значение:

                          var result = multiplyTwoNumbers(5, 10)
                          console.log(result)
                          // выведется 50

                      Однако асинхронные функции, которые используют обратные вызовы, ничего сразу же не&nbsp;возвращают.

                          var photo = downloadPhoto('http://coolcats.com/cat.gif')
                          // photo is 'undefined'!

                      В&nbsp;этом случае скачивание файла займёт очень много времени, и&nbsp;никто не&nbsp;хочет, чтобы программа была приостановлена (то&nbsp;есть заблокирована), пока идёт загрузка.

                      Вместо этого вы&nbsp;сохраняете в&nbsp;функцию код, который должен выполняться после завершения загрузки. **Это и есть обратный вызов!** Адрес изображения передаётся функции `downloadPhoto`, и&nbsp;она запускает наш обратный вызов `handlePhoto`, уже после скачивания.

                          downloadPhoto('http://coolcats.com/cat.gif', handlePhoto)

                          function handlePhoto (error, photo) {
                            if (error) console.error('Download error!', error)
                            else console.log('Download finished', photo)
                          }

                          console.log('Download started')

                      Самая большая проблема при попытке понять функции обратного вызова&nbsp;&mdash; это отсутствие знаний в&nbsp;каком порядке исполняются функции во&nbsp;время работы программы. В&nbsp;нашем примере произошло три крупных события. Сперва объявлена функция `handlePhoto`, потом запущена функция `downloadPhoto`, и&nbsp;ей&nbsp;передана `handlePhoto` в&nbsp;качестве функции обратного вызова. Наконец, было показано сообщение `'Download started'` на&nbsp;экран.

                      Обратите внимание, что `handlePhoto` не была вызвана сразу, она просто создана и&nbsp;передаётся в&nbsp;качестве обратного вызова в `downloadPhoto`. Но&nbsp;она не&nbsp;будет выполнена до&nbsp;тех пор, пока `downloadPhoto` не&nbsp;завершит выполнение своей задачи, которая может занять длительное время в&nbsp;зависимости от&nbsp;того, насколько быстрое у&nbsp;вас подключение к&nbsp;интернету.

                      Этот пример предназначен для демонстрации двух важных понятий:

                      - обратный вызов `handlePhoto`  &mdash; это просто способ отложить какие-то дела на&nbsp;более позднее время;
                      - порядок, в&nbsp;котором всё происходит, не&nbsp;идёт сверху вниз&nbsp;&mdash; он&nbsp;перескакивает в&nbsp;зависимости от&nbsp;того, когда завершаются действия.

                      ## Как выбраться из&nbsp;ада обратных вызовов?

                      Основная причина возникновения такой ситуации&nbsp;&mdash; недостаток практики, но, к&nbsp;счастью, писать хороший код несложно.

                      Вам нужно всего лишь следовать **трём правилам**:

                      ## 1. Не&nbsp;используйте большую вложенность

                      Вот пример неряшливого кода, который использует [browser-request](https://github.com/iriscouch/browser-request) , чтобы создать AJAX-запрос на&nbsp;сервер:

                          var form = document.querySelector('form')
                          form.onsubmit = function (submitEvent) {
                            var name = document.querySelector('input').value
                            request({
                              uri: "http://example.com/upload",
                              body: name,
                              method: "POST"
                            }, function (err, response, body) {
                              var statusMessage = document.querySelector('.status')
                              if (err) return statusMessage.value = err
                              statusMessage.value = body
                            })
                          }

                      Этот код имеет две анонимные функции. Давайте дадим им&nbsp;имена.

                          var form = document.querySelector('form')
                          form.onsubmit = function formSubmit (submitEvent) {
                            var name = document.querySelector('input').value
                            request({
                              uri: "http://example.com/upload",
                              body: name,
                              method: "POST"
                            }, function postResponse (err, response, body) {
                              var statusMessage = document.querySelector('.status')
                              if (err) return statusMessage.value = err
                              statusMessage.value = body
                            })
                          }

                      Как видите, давать имена функциям легко, и&nbsp;это имеет неоспоримые преимущества:

                       - код легче читается, благодаря описательным именам функций;
                       - при исключениях вы&nbsp;получите стек (stack traces), который будет ссылаться на&nbsp;фактические имена функций вместо &laquo;анонимных&raquo;;
                       - позволяет перемещать функции и&nbsp;ссылаться на&nbsp;них по&nbsp;именам.

                      Теперь вы&nbsp;можете переместить функцию на&nbsp;верхний уровень программы:

                          document.querySelector('form').onsubmit = formSubmit

                          function formSubmit (submitEvent) {
                            var name = document.querySelector('input').value
                            request({
                              uri: "http://example.com/upload",
                              body: name,
                              method: "POST"
                            }, postResponse)
                          }

                          function postResponse (err, response, body) {
                            var statusMessage = document.querySelector('.status')
                            if (err) return statusMessage.value = err
                            statusMessage.value = body
                          }

                      Обратите внимание, что объявление функций здесь было осуществлено в&nbsp;самом низу файла. Это произошло благодаря [поднятию функций (function hoisting)](https://gist.github.com/maxogden/4bed247d9852de93c94c).

                      ## 2. Модульность

                      Это самая важная часть: &laquo;*Любой способен создавать модули (или библиотеки)*&raquo;. Цитируя [Исаака Шлютера](http://twitter.com/izs) (из&nbsp;проекта Node.js): *«Пишите маленькие модули, каждый из&nbsp;которых будет выполнять одну функцию и&nbsp;собирайте их&nbsp;в более крупные модули. Вы&nbsp;не&nbsp;сможете попасть в&nbsp;ад&nbsp;обратных вызовов, если не&nbsp;пойдёте туда сами»*.

                      Давайте возьмём наш шаблонный код сверху и&nbsp;превратим в&nbsp;модуль, разделив на&nbsp;несколько файлов. Я&nbsp;покажу как сделать модульный паттерн, который работает с&nbsp;любым браузером и/или сервером:

                      Назовём наш новый файл  `formuploader.js`, он&nbsp;содержит в&nbsp;себе две функции:

                          module.exports.submit = formSubmit

                          function formSubmit (submitEvent) {
                            var name = document.querySelector('input').value
                            request({
                              uri: "http://example.com/upload",
                              body: name,
                              method: "POST"
                            }, postResponse)
                          }

                          function postResponse (err, response, body) {
                            var statusMessage = document.querySelector('.status')
                            if (err) return statusMessage.value = err
                            statusMessage.value = body
                          }

                      `module.exports` &mdash;&nbsp;это небольшой пример модуля, который работает в&nbsp;Node.js, Electron и&nbsp;в браузере через [browserify](https://github.com/substack/node-browserify). Мне очень нравится этот стиль для модулей, так как он&nbsp;работает везде, очень лёгок в&nbsp;понимании и&nbsp;не&nbsp;требует сложных конфигурационных файлов и&nbsp;скриптов.

                      Теперь, когда у&nbsp;нас есть `formuploader.js` (он&nbsp;будет загружен на&nbsp;страницу в&nbsp;тег script после работы browserify), нам просто нужно вызвать и&nbsp;использовать его:

                          var formUploader = require('formuploader')
                          document.querySelector('form').onsubmit = formUploader.submit

                      В результате наше приложение имеет только две строки кода и&nbsp;обладает следующими преимуществами:

                      - лёгкость понимания для новых разработчиков&nbsp;&mdash; у&nbsp;них не&nbsp;будет трудностей с&nbsp;чтением файла `formuploader`;
                      - `formuploader` может быть переиспользован без дублирования кода и&nbsp;легко выложен на&nbsp;github или npm.

                      ## 3. Обрабатывайте каждую ошибку

                      Существуют различные типы ошибок: синтаксические ошибки (обычно появляются при первом запуске программы), ошибки во&nbsp;время исполнения (код начал выполняться, но&nbsp;какая-то ошибка всё испортила), неверное расширение файла, сбой в&nbsp;работе жёсткого диска, отсутствие интернет-соединения и&nbsp;так далее.

                      Соблюдение первых двух правил делает ваш код не&nbsp;только легко читаемым, но&nbsp;и&nbsp;устойчивым к&nbsp;ошибкам. Когда мы&nbsp;имеем дело с&nbsp;обратными вызовами, мы&nbsp;по&nbsp;определению имеем дело с&nbsp;задачами, которые отправились на&nbsp;выполнение, запустились, сделали что-то в&nbsp;фоновом режиме и&nbsp;успешно завершились или прервались из-за ошибки. Любой опытный разработчик подтвердит, что вы&nbsp;никогда не&nbsp;сможете предугадать, когда эти ошибки произойдут, поэтому всегда нужно обрабатывать их, для предотвращения таких случаев.

                      У&nbsp;обратных вызовов самым популярным соглашением обработки ошибок является стиль Node.js, где первый параметр всегда резервируется для ошибок.

                           var fs = require('fs')

                           fs.readFile('/Does/not/exist', handleFile)

                           function handleFile (error, file) {
                             if (error) return console.error('Uhoh, there was an error', error)
                             // в противном случае, продолжай и используй `file` в своём коде
                           }

                      Первый аргумент `error`  не&nbsp;даст вам забыть обработать свои ошибки. Если&nbsp;бы это был второй аргумент, то&nbsp;вы&nbsp;могли написать код так: `function handleFile (file) { }`  и&nbsp;легко пропустить ошибку.

                      Также можно настроить линтеры кода, они помогут не&nbsp;забывать обрабатывать ошибки при обратных вызовах. Самый простой для использования&nbsp;&mdash; [standard](http://standardjs.com/). Всё что нужно сделать&nbsp;&mdash; это запустить команду `$ standard` в&nbsp;своей папке с&nbsp;кодом, и&nbsp;он&nbsp;покажет каждый обратный вызов с&nbsp;необработанной ошибкой.

                      ### Краткий итог

                      1. Избегайте большой вложенности функций. Дайте им&nbsp;имена и&nbsp;разместите их&nbsp;на&nbsp;верхнем уровне программы.
                      2. Используйте [поднятие функций](https://gist.github.com/maxogden/4bed247d9852de93c94c) (function hoisting) чтобы переместить объявление функций в&nbsp;нижнюю часть страницы.
                      3. Обрабатывайте **каждую ошибку** в&nbsp;каждом обратном вызове. Для этого подойдёт линтер [standard](http://standardjs.com/).
                      4. Создавайте переиспользуемые функции и&nbsp;помещайте их&nbsp;в&nbsp;модули, чтобы сократить время для понимания вашего кода. Разделяйте код на&nbsp;маленькие кусочки&nbsp;&mdash; это поможет обрабатывать ошибки, писать тесты, заставит вас создавать стабильный, задокументированный публичный API и&nbsp;облегчит его рефакторинг.

                      Наиболее важный аспект для избавления от&nbsp;ада обратных вызовов&nbsp;&mdash; перемещение функций за&nbsp;пределы основной последовательности действий программы так, чтобы её&nbsp;поток выполнения был более понятен, и&nbsp;новичкам не&nbsp;было необходимости разбираться со&nbsp;всеми деталями функций, чтобы уловить суть того, что программа пытается сделать.

                      Можете начать перемещать функции в&nbsp;конец файла, затем переместить их&nbsp;в&nbsp;другой файл, который вы&nbsp;будете загружать как `require('./photo-helpers.js')` а&nbsp;потом переместить их&nbsp;в&nbsp;отдельный модуль `require('image-resize')`.

                      Вот некоторые эмпирические правила при создании модуля:

                      - начните с&nbsp;перемещения неоднократно использованного кода в&nbsp;функцию.
                      - когда ваша функция (или группа функций связанных одной темой) получится достаточно большой, переместите её&nbsp;в&nbsp;другой файл и&nbsp;вызывайте используя `module.exports`. Вы&nbsp;можете загружать новый модуль, используя относительный вызов;
                      - если у&nbsp;вас есть код, который может быть использован в&nbsp;нескольких проектах, создайте для него описание, тесты, `package.json` и&nbsp;опубликуйте на&nbsp;github и&nbsp;npm. У&nbsp;этого подхода есть много преимуществ, но&nbsp;я&nbsp;не&nbsp;буду перечислять их&nbsp;здесь;
                      - хороший модуль — небольшой, и&nbsp;фокусируется на&nbsp;одной проблеме;
                      - в&nbsp;файле модуля не&nbsp;должно быть больше 150 строчек кода;
                      - модуль не&nbsp;должен иметь более одного уровня вложенности папок или JavaScript-файлов. Если это произошло, то, вероятно, он делает слишком много всего;
                      - просите более опытных программистов показать примеры хороших модулей, чтобы у&nbsp;вас сложилось правильное представление о&nbsp;том, как они должны выглядеть. Если понимание того, что происходит в&nbsp;модуле занимает по&nbsp;времени больше чем несколько минут, то&nbsp;это не&nbsp;очень хороший модуль.

                      ### Что читать?

                      Попробуйте прочесть моё [большое введение в&nbsp;обратные вызовы](https://github.com/maxogden/art-of-node#callbacks), или пройти несколько уроков в&nbsp;[nodeschool](http://nodeschool.io/ru/).

                      Ещё почитайте [карманный справочник browserify](https://github.com/substack/browserify-handbook) в&nbsp;качестве примера того, как стоит писать модульный код.

                      ### А&nbsp;что насчёт промисов, генераторов, ES6?

                      Помните, что обратные вызовы&nbsp;&mdash; фундаментальная часть JavaScript (поскольку являются просто функциями) и&nbsp;вы&nbsp;должны научиться читать и&nbsp;писать их&nbsp;прежде, чем переходить к&nbsp;более продвинутым функциям языка, так как все они зависят от&nbsp;понимания обратных вызовов. Если вы&nbsp;пока не&nbsp;можете написать удобный для поддержки код обратных вызовов, то&nbsp;продолжайте работать над этим.

                      Если вы&nbsp;действительно хотите, чтобы ваш асинхронный код читался сверху вниз, то&nbsp;есть некоторые необычные свойства, которые можно попробовать. Обратите внимание&nbsp;&mdash; **они могут снизить производительность и спровоцировать кроссплатформенные проблемы совместимости во&nbsp;время выполнения**, поэтому убедитесь, что всё предусмотрели.

                      **Промисы** &nbsp;&mdash; это путь написания асинхронного кода, который выглядит так, будто он&nbsp;исполняется сверху вниз и&nbsp;обрабатывает больше типов ошибок из-за использования `try/catch`.

                      **Генераторы**  могут «приостановить» отдельную функцию без паузы для всей программы, за&nbsp;счёт чуть более сложного кода, они позволяют вашему асинхронному коду выполняться сверху вниз. Посмотрите на пример такого подхода — [watt](https://github.com/mappum/watt).

                      **Асинхронные функции** &nbsp;&mdash; предложенная особенность ES7, которая обернёт генераторы и&nbsp;промисы в&nbsp;высокоуровневый синтаксис. Если они вас заинтересовали, то можете изучить их подробнее.

                      Я&nbsp;использую обратные вызовы в&nbsp;90% случаях при написании асинхронного кода и&nbsp;лишь когда всё становится сложно,&nbsp;перехожу на&nbsp;[run-parallel](https://github.com/feross/run-parallel) или [run-series](https://github.com/feross/run-series). Не&nbsp;думаю, что мне нужны обратные вызовы, промисы или что-то подобное, так как гораздо важнее сохранить код простым, не&nbsp;вложенным и&nbsp;разделённым на&nbsp;маленькие модули.

                      Независимо от&nbsp;метода, который вы&nbsp;выберите, всегда **обрабатывайте ошибки** и&nbsp;

                      ### Помните, только *вы*&nbsp;можете предотвратить ад&nbsp;обратных вызовов и&nbsp;лесные пожары.

                      Это перевод статьи Max Ogden&nbsp;&mdash; &laquo;[Callback Hell](http://callbackhell.com/)&raquo;.

                      Вы можете найти исходники [на Гитхабе](https://github.com/htmlacademy/callback-hell).
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <script src="javascripts/marked.js"></script>
    <script type="text/javascript">

      var content = document.querySelector('.post-content')
      content.setAttribute('style', "white-space: normal;")

      // kinda hacky but whatever
      var lines = content.innerHTML.split('\n')
      var baseIndent = lines[1].split('#')[0]

      lines = lines.map(function iterator(line) {
        return line.replace(baseIndent, '')
      })

      var trimmed = lines.join('\n')
      content.innerHTML = marked(trimmed)
    </script>

    <script src="javascripts/rainbow.js"></script>
    <script src="javascripts/generic.js"></script>
    <script src="javascripts/javascript.js"></script>
    <script type="text/javascript">

      var codeBlocks = document.querySelectorAll('code')

      Array.prototype.forEach.call(codeBlocks, function iterator(block) {
        block.innerHTML = unescapeEntities(block.innerHTML)
        block.setAttribute('data-language', 'javascript')
      })

      Rainbow.color()

      // markdown is dumb and always escapes &, < and > with no way to override
      function unescapeEntities(text) {
        function un(text) {
          var d = document.createElement("div")
          d.innerHTML = text
          return d.innerText || d.text || d.textContent
        }
        // need to unescape twice
        // > -> &amp;gt; -> &gt; -> >
        return un(un(text))
      }

    </script>

    <script type="text/javascript">
      var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
      document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/JavaScript'%3E%3C/script%3E"));
    </script>
    <script type="text/javascript">
      try {
        var pageTracker = _gat._getTracker("UA-33352116-1");
      pageTracker._trackPageview();
      } catch(err) {}
    </script>

  </body>
</html>
